"""Tests for Sieve script generator."""

import pytest

from src.generator.sieve_generator import (
    SieveGenerator, EXTENSION_MAP, SECTION_BEGIN, SECTION_END,
)
from src.models.filter_models import (
    ConsolidatedFilter, ConditionGroup, FilterCondition, FilterAction,
    ConditionType, Operator, ActionType, LogicType,
)


class TestSieveGenerator:
    """Test SieveGenerator class."""

    def test_generate_empty_list(self):
        """Test generating Sieve script from empty filter list."""
        gen = SieveGenerator()

        script = gen.generate([])

        assert isinstance(script, str)
        assert "ProtonFusion" in script

    def test_generate_header_comment(self):
        """Test that generated script includes header comment."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert "ProtonFusion" in script
        assert "Generated by ProtonFusion" in script
        assert "Total rules:" in script

    def test_generate_require_statement(self):
        """Test that require statement includes necessary extensions."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.MOVE_TO, parameters={"folder": "Test"})]
        )

        script = gen.generate([cf])

        assert "require" in script
        assert "fileinto" in script

    def test_generate_simple_delete_rule(self):
        """Test generating a simple delete rule."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Delete Spam",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="spam@test.com")
            ])],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert "if" in script
        assert "address" in script
        assert "From" in script
        assert "spam@test.com" in script
        assert "discard;" in script

    def test_generate_move_to_folder(self):
        """Test generating move to folder action."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Move to Spam",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(type=ConditionType.SUBJECT, operator=Operator.CONTAINS, value="urgent")
            ])],
            actions=[FilterAction(type=ActionType.MOVE_TO, parameters={"folder": "Spam"})]
        )

        script = gen.generate([cf])

        assert "fileinto" in script
        assert '"Spam"' in script

    def test_generate_mark_read(self):
        """Test generating mark as read action."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Mark Read",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.MARK_READ)]
        )

        script = gen.generate([cf])

        assert "addflag" in script
        assert "Seen" in script

    def test_generate_star(self):
        """Test generating star action."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Star",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.STAR)]
        )

        script = gen.generate([cf])

        assert "addflag" in script
        assert "Flagged" in script

    def test_generate_archive(self):
        """Test generating archive action."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Archive",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.ARCHIVE)]
        )

        script = gen.generate([cf])

        assert "fileinto" in script
        assert '"Archive"' in script

    def test_generate_label(self):
        """Test generating label action."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Label",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.LABEL, parameters={"label": "Important"})]
        )

        script = gen.generate([cf])

        assert "fileinto" in script
        assert '"Important"' in script

    def test_generate_sender_condition(self):
        """Test generating sender condition."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="test@example.com")
            ])],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert "address" in script
        assert "From" in script
        assert "test@example.com" in script

    def test_generate_recipient_condition(self):
        """Test generating recipient condition checks To, Cc, and Bcc."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(type=ConditionType.RECIPIENT, operator=Operator.IS, value="me@example.com")
            ])],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert "address" in script
        assert '["To", "Cc", "Bcc"]' in script
        assert "me@example.com" in script

    def test_generate_subject_condition(self):
        """Test generating subject condition."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(type=ConditionType.SUBJECT, operator=Operator.CONTAINS, value="urgent")
            ])],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert "header" in script
        assert "Subject" in script
        assert "urgent" in script

    def test_generate_contains_operator(self):
        """Test generating contains operator."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="test")
            ])],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert ":contains" in script

    def test_generate_is_operator(self):
        """Test generating is operator."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(type=ConditionType.SENDER, operator=Operator.IS, value="test@example.com")
            ])],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert ":is" in script

    def test_generate_matches_operator(self):
        """Test generating matches operator (built-in, no extension needed)."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(type=ConditionType.SENDER, operator=Operator.MATCHES, value="*@spam.com")
            ])],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert ":matches" in script
        # :matches is a built-in Sieve comparator; it must NOT pull in "regex"
        assert "regex" not in script

    def test_generate_or_logic_within_group(self):
        """Test generating OR logic (anyof) within a single condition group."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(
                logic=LogicType.OR,
                conditions=[
                    FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="spam1"),
                    FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="spam2"),
                ],
            )],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert "anyof" in script

    def test_generate_and_logic_within_group(self):
        """Test generating AND logic (allof) within a single condition group."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(
                logic=LogicType.AND,
                conditions=[
                    FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="test"),
                    FilterCondition(type=ConditionType.SUBJECT, operator=Operator.CONTAINS, value="urgent"),
                ],
            )],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert "allof" in script

    def test_generate_merged_conditions_array(self):
        """Test generating array from merged conditions (pipe-delimited values)."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="spam1@test.com|spam2@test.com|spam3@test.com")
            ])],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert "[" in script
        assert "spam1@test.com" in script
        assert "spam2@test.com" in script
        assert "spam3@test.com" in script

    def test_generate_multiple_actions(self):
        """Test generating multiple actions."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[],
            actions=[
                FilterAction(type=ActionType.LABEL, parameters={"label": "Important"}),
                FilterAction(type=ActionType.MARK_READ),
            ]
        )

        script = gen.generate([cf])

        assert "fileinto" in script
        assert "Important" in script
        assert "addflag" in script
        assert "Seen" in script

    def test_generate_source_filter_comment(self):
        """Test that source filters are added as comments."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Consolidated",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.DELETE)],
            source_filters=["Filter 1", "Filter 2", "Filter 3"],
            filter_count=3
        )

        script = gen.generate([cf])

        assert "# Consolidated" in script
        assert "Filter 1" in script

    def test_generate_many_source_filters_truncated(self):
        """Test that many source filters are truncated in comments."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Consolidated",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.DELETE)],
            source_filters=[f"Filter {i}" for i in range(10)],
            filter_count=10
        )

        script = gen.generate([cf])

        assert "... and" in script
        assert "more" in script

    def test_escape_special_characters(self):
        """Test escaping special characters in Sieve strings."""
        gen = SieveGenerator()

        escaped = gen._escape_sieve('test"quote')
        assert '\\"' in escaped

        escaped = gen._escape_sieve('test\\backslash')
        assert '\\\\' in escaped

    def test_generate_multiple_filters(self):
        """Test generating script with multiple filters."""
        gen = SieveGenerator()
        filters = [
            ConsolidatedFilter(
                name="Delete Spam",
                condition_groups=[ConditionGroup(conditions=[
                    FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="spam")
                ])],
                actions=[FilterAction(type=ActionType.DELETE)]
            ),
            ConsolidatedFilter(
                name="Archive News",
                condition_groups=[ConditionGroup(conditions=[
                    FilterCondition(type=ConditionType.SUBJECT, operator=Operator.CONTAINS, value="newsletter")
                ])],
                actions=[FilterAction(type=ActionType.ARCHIVE)]
            ),
        ]

        script = gen.generate(filters)

        assert "Delete Spam" in script or "discard" in script
        assert "Archive News" in script or "Archive" in script
        assert script.count("if ") == 2

    def test_generate_no_conditions(self):
        """Test generating filter with no conditions."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Unconditional",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        # Should have action without if statement
        assert "discard;" in script

    def test_collect_extensions_fileinto(self):
        """Test that fileinto extension is collected."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.MOVE_TO, parameters={"folder": "Test"})]
        )

        extensions = gen._collect_extensions([cf])

        assert "fileinto" in extensions

    def test_collect_extensions_imap4flags(self):
        """Test that imap4flags extension is collected."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[],
            actions=[FilterAction(type=ActionType.MARK_READ)]
        )

        extensions = gen._collect_extensions([cf])

        assert "imap4flags" in extensions

    def test_matches_does_not_collect_regex_extension(self):
        """Test that :matches (built-in) does not add 'regex' extension."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(type=ConditionType.SENDER, operator=Operator.MATCHES, value="*@spam.com")
            ])],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        extensions = gen._collect_extensions([cf])

        assert "regex" not in extensions

    def test_generate_real_world_example(self):
        """Test generating a realistic consolidated filter."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Delete spam (consolidated from 5 filters)",
            condition_groups=[ConditionGroup(
                logic=LogicType.OR,
                conditions=[
                    FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="spam1@test.com|spam2@test.com|spam3@test.com"),
                ],
            )],
            actions=[FilterAction(type=ActionType.DELETE)],
            source_filters=["Spam Filter 1", "Spam Filter 2", "Spam Filter 3"],
            filter_count=3
        )

        script = gen.generate([cf])

        assert "require" not in script or "require" in script  # May or may not need extensions
        assert "Delete spam" in script or "Spam Filter" in script
        assert "discard;" in script
        assert "spam1@test.com" in script

    def test_generate_multiple_condition_groups_anyof(self):
        """Test that multiple condition groups produce outer anyof."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Consolidated",
            condition_groups=[
                ConditionGroup(conditions=[
                    FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="alice")
                ]),
                ConditionGroup(conditions=[
                    FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="bob")
                ]),
            ],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert "anyof" in script
        assert "alice" in script
        assert "bob" in script

    def test_generate_and_group_produces_allof(self):
        """Test that an AND condition group renders as allof."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="AND test",
            condition_groups=[ConditionGroup(
                logic=LogicType.AND,
                conditions=[
                    FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="alice"),
                    FilterCondition(type=ConditionType.SUBJECT, operator=Operator.CONTAINS, value="urgent"),
                ],
            )],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        assert "allof" in script
        assert "alice" in script
        assert "urgent" in script

    def test_generate_comma_separated_values_expanded_to_array(self):
        """Test that ProtonMail comma-separated values are expanded into Sieve arrays.

        ProtonMail stores multiple values in a single condition field as
        "val1, val2, val3". These must become Sieve array elements, not a
        single string literal.
        """
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="dumb services",
            condition_groups=[ConditionGroup(
                logic=LogicType.OR,
                conditions=[
                    FilterCondition(
                        type=ConditionType.SENDER,
                        operator=Operator.CONTAINS,
                        value="redfin.com, zillow.com, ebay.com",
                    ),
                    FilterCondition(
                        type=ConditionType.SUBJECT,
                        operator=Operator.CONTAINS,
                        value="[IEEE-Announcements]",
                    ),
                ],
            )],
            actions=[
                FilterAction(type=ActionType.MOVE_TO, parameters={"folder": "Company Comms/myjunk"}),
                FilterAction(type=ActionType.MARK_READ),
            ],
        )

        script = gen.generate([cf])

        # Each comma-separated value must be a separate array element
        assert '["redfin.com", "zillow.com", "ebay.com"]' in script
        # Single values should NOT become arrays
        assert '"[IEEE-Announcements]"' in script

    def test_generate_comma_separated_with_pipe_merged(self):
        """Test comma-separated values combined with pipe-merged values."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Test",
            condition_groups=[ConditionGroup(conditions=[
                FilterCondition(
                    type=ConditionType.SENDER,
                    operator=Operator.CONTAINS,
                    # Pipe from merge_conditions, commas from ProtonMail
                    value="a.com, b.com|c.com, d.com",
                ),
            ])],
            actions=[FilterAction(type=ActionType.DELETE)],
        )

        script = gen.generate([cf])

        assert '"a.com"' in script
        assert '"b.com"' in script
        assert '"c.com"' in script
        assert '"d.com"' in script

    def test_generate_mixed_and_or_groups(self):
        """Test rendering consolidated filter with AND and single-condition groups."""
        gen = SieveGenerator()
        cf = ConsolidatedFilter(
            name="Mixed",
            condition_groups=[
                # AND group: sender=alice AND subject=urgent
                ConditionGroup(
                    logic=LogicType.AND,
                    conditions=[
                        FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="alice"),
                        FilterCondition(type=ConditionType.SUBJECT, operator=Operator.CONTAINS, value="urgent"),
                    ],
                ),
                # Single-condition group: sender=bob
                ConditionGroup(conditions=[
                    FilterCondition(type=ConditionType.SENDER, operator=Operator.CONTAINS, value="bob"),
                ]),
            ],
            actions=[FilterAction(type=ActionType.DELETE)]
        )

        script = gen.generate([cf])

        # Outer anyof (multiple groups), inner allof (AND group)
        assert "anyof" in script
        assert "allof" in script
        assert "alice" in script
        assert "urgent" in script
        assert "bob" in script


class TestParseRequireExtensions:
    """Test SieveGenerator.parse_require_extensions()."""

    def test_single_extension(self):
        script = 'require ["fileinto"];\n\nif true { fileinto "Spam"; }'
        exts = SieveGenerator.parse_require_extensions(script)
        assert exts == {"fileinto"}

    def test_multiple_extensions(self):
        script = 'require ["fileinto", "imap4flags", "regex"];\n'
        exts = SieveGenerator.parse_require_extensions(script)
        assert exts == {"fileinto", "imap4flags", "regex"}

    def test_no_require(self):
        script = "if true { discard; }\n"
        exts = SieveGenerator.parse_require_extensions(script)
        assert exts == set()

    def test_multiple_require_lines(self):
        script = 'require ["fileinto"];\nrequire ["imap4flags"];\n'
        exts = SieveGenerator.parse_require_extensions(script)
        assert exts == {"fileinto", "imap4flags"}

    def test_require_with_whitespace(self):
        script = '  require  ["fileinto"] ;\n'
        exts = SieveGenerator.parse_require_extensions(script)
        assert exts == {"fileinto"}


class TestStripRequireLines:
    """Test SieveGenerator.strip_require_lines()."""

    def test_strips_require(self):
        script = 'require ["fileinto"];\n\n# comment\nif true { discard; }\n'
        result = SieveGenerator.strip_require_lines(script)
        assert "require" not in result
        assert "# comment" in result
        assert "discard" in result

    def test_no_require(self):
        script = "# just comments\nif true { discard; }\n"
        result = SieveGenerator.strip_require_lines(script)
        assert result == script

    def test_multiple_requires(self):
        script = 'require ["fileinto"];\nrequire ["imap4flags"];\n# rule\n'
        result = SieveGenerator.strip_require_lines(script)
        assert "require" not in result
        assert "# rule" in result


class TestWrapWithMarkers:
    """Test SieveGenerator.wrap_with_markers()."""

    def test_basic_wrap(self):
        script = '# comment\nif true { discard; }\n'
        result = SieveGenerator.wrap_with_markers(script)
        assert result.startswith(SECTION_BEGIN)
        assert result.endswith(SECTION_END)
        assert "# comment" in result
        assert "discard" in result

    def test_strips_require_before_wrapping(self):
        script = 'require ["fileinto"];\n\n# rule\nif true { fileinto "Spam"; }\n'
        result = SieveGenerator.wrap_with_markers(script)
        assert "require" not in result
        assert SECTION_BEGIN in result
        assert SECTION_END in result
        assert "# rule" in result


class TestMergeWithExisting:
    """Test SieveGenerator.merge_with_existing()."""

    def _make_generated(self):
        """Create a sample generated ProtonFusion script."""
        return (
            'require ["fileinto"];\n'
            "\n"
            "# ProtonFusion - Filter Consolidation\n"
            "# Generated by ProtonFusion v0.1.0\n"
            "# Total rules: 1\n"
            "\n"
            'if address :contains "From" "spam@example.com" {\n'
            '    fileinto "Spam";\n'
            "}\n"
        )

    def test_no_existing_script(self):
        generated = self._make_generated()
        result = SieveGenerator.merge_with_existing(generated, "")

        assert result.startswith('require ["fileinto"];')
        assert SECTION_BEGIN in result
        assert SECTION_END in result
        assert "spam@example.com" in result

    def test_no_existing_script_none_like(self):
        generated = self._make_generated()
        result = SieveGenerator.merge_with_existing(generated, "   \n  \n  ")

        assert SECTION_BEGIN in result
        assert SECTION_END in result

    def test_existing_user_rules_only(self):
        generated = self._make_generated()
        existing = (
            'require ["imap4flags"];\n'
            "\n"
            'if header :contains "X-Custom" "value" {\n'
            '    addflag "\\\\Seen";\n'
            "}\n"
        )
        result = SieveGenerator.merge_with_existing(generated, existing)

        # Merged require should have both extensions
        assert '"fileinto"' in result
        assert '"imap4flags"' in result

        # ProtonFusion section comes first
        begin_pos = result.index(SECTION_BEGIN)
        end_pos = result.index(SECTION_END)
        user_pos = result.index("X-Custom")
        assert begin_pos < end_pos < user_pos

        # User rules preserved
        assert "X-Custom" in result
        assert "Seen" in result

        # Only one require statement at top
        require_count = result.count("require [")
        assert require_count == 1

    def test_existing_protonfusion_replaced(self):
        generated = self._make_generated()
        existing = (
            'require ["fileinto"];\n'
            "\n"
            f"{SECTION_BEGIN}\n"
            "# ProtonFusion - old rules\n"
            'if address :contains "From" "old@example.com" {\n'
            '    fileinto "OldFolder";\n'
            "}\n"
            f"{SECTION_END}\n"
            "\n"
            '# User custom rules\n'
            'if header :contains "X-Custom" "keep" {\n'
            '    fileinto "Custom";\n'
            "}\n"
        )
        result = SieveGenerator.merge_with_existing(generated, existing)

        # Old ProtonFusion rules replaced
        assert "old@example.com" not in result
        assert "OldFolder" not in result

        # New rules present
        assert "spam@example.com" in result

        # User rules preserved
        assert "X-Custom" in result
        assert "Custom" in result

    def test_existing_protonfusion_only(self):
        generated = self._make_generated()
        existing = (
            'require ["fileinto"];\n'
            "\n"
            f"{SECTION_BEGIN}\n"
            "# old rules\n"
            f"{SECTION_END}\n"
        )
        result = SieveGenerator.merge_with_existing(generated, existing)

        assert SECTION_BEGIN in result
        assert SECTION_END in result
        assert "spam@example.com" in result
        # No user rules section trailing
        after_end = result.split(SECTION_END)[1]
        assert after_end.strip() == ""

    def test_require_dedup(self):
        generated = 'require ["fileinto", "imap4flags"];\n\n# rule\nif true { discard; }\n'
        existing = 'require ["fileinto", "regex"];\n\n# user rule\nif true { keep; }\n'
        result = SieveGenerator.merge_with_existing(generated, existing)

        # All three extensions present, but only one require line
        assert '"fileinto"' in result
        assert '"imap4flags"' in result
        assert '"regex"' in result
        assert result.count("require [") == 1

    def test_require_sorted(self):
        generated = 'require ["regex", "fileinto"];\n\n# rule\n'
        existing = 'require ["imap4flags"];\n\n# user\n'
        result = SieveGenerator.merge_with_existing(generated, existing)

        # Extensions should be alphabetically sorted
        require_line = [l for l in result.split("\n") if l.startswith("require")][0]
        assert '"fileinto"' in require_line
        assert require_line.index('"fileinto"') < require_line.index('"imap4flags"')
        assert require_line.index('"imap4flags"') < require_line.index('"regex"')

    def test_no_require_in_either(self):
        generated = "# ProtonFusion\nif true { discard; }\n"
        existing = "# user rule\nif false { keep; }\n"
        result = SieveGenerator.merge_with_existing(generated, existing)

        assert "require" not in result
        assert SECTION_BEGIN in result
        assert SECTION_END in result
        assert "discard" in result
        assert "keep" in result

    def test_markers_not_duplicated(self):
        generated = self._make_generated()
        result = SieveGenerator.merge_with_existing(generated, "")
        # Run merge again on the result (simulate re-sync)
        result2 = SieveGenerator.merge_with_existing(generated, result)

        assert result2.count(SECTION_BEGIN) == 1
        assert result2.count(SECTION_END) == 1
