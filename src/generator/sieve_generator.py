"""Generate Sieve scripts from consolidated filters."""

import logging
from typing import List, Set

from src.models.filter_models import (
    ConsolidatedFilter, ConditionGroup, FilterCondition, FilterAction,
    ConditionType, Operator, ActionType, LogicType,
)

logger = logging.getLogger(__name__)

# Sieve extensions needed for various features
EXTENSION_MAP = {
    ActionType.MOVE_TO: "fileinto",
    ActionType.LABEL: "fileinto",  # Labels use fileinto in ProtonMail
    ActionType.DELETE: None,  # discard is built-in
    ActionType.MARK_READ: "imap4flags",
    ActionType.STAR: "imap4flags",
    ActionType.ARCHIVE: "fileinto",
}


class SieveGenerator:
    """Generate Sieve scripts from consolidated filters."""

    def generate(self, filters: List[ConsolidatedFilter]) -> str:
        """Generate a complete Sieve script from consolidated filters."""
        lines = []

        # Collect required extensions
        extensions = self._collect_extensions(filters)

        # Generate require statement
        if extensions:
            ext_list = ", ".join(f'"{ext}"' for ext in sorted(extensions))
            lines.append(f"require [{ext_list}];")
            lines.append("")

        # Generate header comment
        lines.append("# ProtonFusion - Filter Consolidation")
        lines.append(f"# Generated by ProtonFusion v0.1.0")
        lines.append(f"# Total rules: {len(filters)}")
        lines.append("")

        # Generate rules
        first = True
        for i, f in enumerate(filters):
            if not first:
                lines.append("")

            # Add comment with source filter info
            if f.source_filters:
                if f.filter_count > 1:
                    lines.append(f"# {f.name}")
                    lines.append(f"# Source filters: {', '.join(f.source_filters[:5])}")
                    if len(f.source_filters) > 5:
                        lines.append(f"#   ... and {len(f.source_filters) - 5} more")
                else:
                    lines.append(f"# {f.source_filters[0]}")

            # Generate the rule
            condition_str = self._generate_conditions(f)
            action_lines = self._generate_actions(f)

            if condition_str:
                lines.append(f"if {condition_str} {{")
                for action_line in action_lines:
                    lines.append(f"    {action_line}")
                lines.append("}")
            else:
                # No conditions = unconditional rule (rare)
                for action_line in action_lines:
                    lines.append(action_line)

            first = False

        # Final newline
        lines.append("")

        script = "\n".join(lines)
        logger.info("Generated Sieve script: %d lines, %d rules", len(lines), len(filters))
        return script

    def _collect_extensions(self, filters: List[ConsolidatedFilter]) -> Set[str]:
        """Determine which Sieve extensions are needed."""
        extensions = set()

        for f in filters:
            for action in f.actions:
                ext = EXTENSION_MAP.get(action.type)
                if ext:
                    extensions.add(ext)

            for group in f.condition_groups:
                for cond in group.conditions:
                    if cond.operator == Operator.MATCHES:
                        extensions.add("regex")

        return extensions

    def _generate_conditions(self, f: ConsolidatedFilter) -> str:
        """Generate the Sieve condition expression from condition groups."""
        if not f.condition_groups:
            return ""

        # Filter out empty groups
        non_empty = [g for g in f.condition_groups if g.conditions]
        if not non_empty:
            return ""

        if len(non_empty) == 1:
            return self._generate_group(non_empty[0])

        # Multiple groups - OR them together (any group matching triggers action)
        parts = []
        for group in non_empty:
            part = self._generate_group(group)
            if part:
                parts.append(part)

        if not parts:
            return ""
        if len(parts) == 1:
            return parts[0]

        inner = ",\n    ".join(parts)
        return f"anyof (\n    {inner}\n)"

    def _generate_group(self, group: ConditionGroup) -> str:
        """Generate conditions for a single ConditionGroup."""
        if not group.conditions:
            return ""

        parts = []
        for cond in group.conditions:
            sieve_cond = self._condition_to_sieve(cond)
            if sieve_cond:
                parts.append(sieve_cond)

        if not parts:
            return ""
        if len(parts) == 1:
            return parts[0]

        joiner = "anyof" if group.logic == LogicType.OR else "allof"
        inner = ",\n        ".join(parts)
        return f"{joiner} (\n        {inner}\n    )"

    def _condition_to_sieve(self, cond: FilterCondition) -> str:
        """Convert a single condition to Sieve syntax."""
        comparator = self._operator_to_sieve(cond.operator)

        # Handle pipe-delimited values (merged conditions)
        values = cond.value.split("|") if "|" in cond.value else [cond.value]

        if len(values) == 1:
            value_str = f'"{self._escape_sieve(values[0])}"'
        else:
            escaped = [f'"{self._escape_sieve(v)}"' for v in values]
            value_str = "[" + ", ".join(escaped) + "]"

        if cond.type == ConditionType.SENDER:
            return f'address {comparator} "From" {value_str}'
        elif cond.type == ConditionType.RECIPIENT:
            return f'address {comparator} "To" {value_str}'
        elif cond.type == ConditionType.SUBJECT:
            return f'header {comparator} "Subject" {value_str}'
        elif cond.type == ConditionType.ATTACHMENTS:
            return "true"  # Simplified - ProtonMail handles attachments differently
        elif cond.type == ConditionType.HEADER:
            return f'header {comparator} "X-Custom" {value_str}'

        return f'header {comparator} "From" {value_str}'

    def _operator_to_sieve(self, op: Operator) -> str:
        """Convert operator to Sieve comparator."""
        mapping = {
            Operator.CONTAINS: ":contains",
            Operator.IS: ":is",
            Operator.MATCHES: ":matches",
            Operator.STARTS_WITH: ":matches",  # Uses wildcard pattern
            Operator.ENDS_WITH: ":matches",    # Uses wildcard pattern
            Operator.HAS: ":contains",
        }
        return mapping.get(op, ":contains")

    def _generate_actions(self, f: ConsolidatedFilter) -> List[str]:
        """Generate Sieve action statements."""
        lines = []

        for action in f.actions:
            if action.type == ActionType.MOVE_TO:
                folder = action.parameters.get("folder", "INBOX")
                lines.append(f'fileinto "{self._escape_sieve(folder)}";')
            elif action.type == ActionType.LABEL:
                label = action.parameters.get("label", action.parameters.get("folder", ""))
                if label:
                    lines.append(f'fileinto "{self._escape_sieve(label)}";')
            elif action.type == ActionType.MARK_READ:
                lines.append('addflag "\\\\Seen";')
            elif action.type == ActionType.STAR:
                lines.append('addflag "\\\\Flagged";')
            elif action.type == ActionType.ARCHIVE:
                lines.append('fileinto "Archive";')
            elif action.type == ActionType.DELETE:
                lines.append("discard;")

        if not lines:
            lines.append("keep;")

        return lines

    def _escape_sieve(self, value: str) -> str:
        """Escape special characters for Sieve strings."""
        return value.replace("\\", "\\\\").replace('"', '\\"')
